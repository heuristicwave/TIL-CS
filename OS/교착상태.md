## 교착상태

한 프로세스가 자원을 요청했을 때, 자원을 사용할 수 없는 상황이 발생할 수 있고, 그 경우 프로세스는 대기 상태로 돌아간다. 이처럼 대기 중인 프로세스들이 결코 다시는 그 상태를 변경시킬 수 없으면 이런 상황을 **교착상태**라 부른다.



### 교착상태의 특징

#### 필요조건들

교착상태는 한 시스템에 다음 네 가지 조건이 동시에 성립될 때 발생할 수 있다.

1. 상호 배제 : 최소한 하나의 자원이 비공유 모드로 점유되어야 한다. 다른 프로세스가 그 자원을 요청하면, 요청 프로세스는 자원이 방출될 때까지 반드시 지연되어야 한다.
2. 점유하며 대기 : 프로세스는 최소한 하나의 자원을 점유한 채, 현재 다른 프로세스에 의해 점유된 자원을 추가로 얻기 위해 반드시 대기해야 한다.
3. 비선점 : 자원들은 선점할 수 없어야 한다. 즉, 자원이 강제적으로 방출될 수 없고, 점유하고 있는 프로세스가 태스크를 종료한 후 그 프로세스에 의해 자발적으로만 방출될 수 있다.
4. 순환대기 : 대기하고 있는 프로세스 집합에서 자원을 기다리는 프로세스간의 사이클이 형성되어야 함



#### 자원할당 그래프

교착상태는 **시스템 자원 할당 그래프**라고 하는 방향 그래프로 보다 정확하게 기술할 수 있다. 자원 할당 그래프의 정의로부터, 만일 그래프가 사이클을 포함하지 않으면 시스템 내 어느 프로세스도 교착상태가 아니라는 것을 보일 수 있다. 반면, 그래프가 사이클을 포함하면 교착상태가 존재할 수 있다.



### 교착상태 예방

예방 알고리즘은 요청 방법에 제한을 두어 교착상태를 예방한다. 그러나 이런 방식으로 교착상태를 예방할 때 가능한 부수적인 문제는 장치의 이용률이 저하되고 시스템 처리율이 감소된다는 것이다.

#### 상호 배제

하나의 자원은 공유가 불가능한 자원이어야 한다. 반면에, 공유 가능한 자원들은 배터적인 접근을 요구하지 않으며, 따라서 교착상태에 관련될 수 없다. 예를 들어 일기 전용의 파일의 경우 동시 접근을 허용하며 이것은 공유 가능한 자원을 위해 대기할 필요가 없다. 그러나 일반적으로 상호 배제 조건을 거부함으로써 교착상태를 예방하는 것은 불가능하다

#### 점유하며 대기

프로세스가 자원을 요청할 때는 다른 자원들을 점유하지 않을 것을 반드시 보장해야 한다.

많은 자원들이 할당된 후 오랫 동안 사용되지 않기 때문에 자원의 이용도가 낮아질수 있고,  자원들을 여러 개 필요로 하는 프로세스는 자신이 필요한 자원 중에서 최소한 하나가 항상 다른 프로세스들에게 할당되어 있기 떄문에, 무한정 대기해야 할 수도 있다.



### 교착상태 회피

교착상태를 회피하는 다른 대안은 자원이 어떻게 요청될 지에 대한 추가 정보를 제공하도록 요구하는 것이다.

가장 단순하고 유용한 모델은 각 프로세스가 자신이 필요로 하는 각 타입의 자원마다 최대 수를 선언하도록 요구하는 것이다. **최대 수** 정보를 미리 파악할 수 있다면, 우리는 시스템이 교착상태에 들어가지 않을 것을 보장하는 알고리즘을 만들 수 있다. 교착상태 회피 알고리즘은 시스템에 순환 대기 상황이 발생하지 않도록 자원 할당 상태를 검사한다. 자원 할당 상태는 가용 자원의 수, 할당된 자원의 수 그리고 프로세스들의 최대 요구 수에 의해 정의된다.



#### 안전 상태

안전하다는 말은 시스템이 어떤 순서로든 프로세스들이 요청하는 모든 자원을 교착상태를 야기시키지 않고 차례로 모두 할당해 줄 수 있다는 것을 뜻한다. 즉, 시스템의 **안전 순서**를 찾을 수 있다면 시스템은 안전하다고 말한다. 모든 프로세스들을 무사히 마칠 수 있는 순서를 찾을 수 없으면 **불안전**하다고 한다.

시스템의 상태가 안전하다면 교착상태가 아니며, 반대로 교착상태에 있는 시스템은 불안전한 상태에 있다. 그러나 시스템이 불안전하다는 말은 "앞으로 교착상태로 가게 될 수도 있다"는 뜻이다. 



#### 교착상태 문제를 해결하기 위한 방안

- 자원 할당 그래프 알고리즘
- 은행원 알고리즘
- 안전성 알고리즘
- 자원 요청 알고리즘



### 교착상태 탐지

- 교착상태가 발생했는지 결정하기 위해 시스템의 상태를 검사하는 알고리즘
- 교착상태로부터 회복하는 알고리즘

탐지와 회복 방법이, 필요한 정보를 유지하고 탐지 알고리즘을 실행시키기 위한 실행 시간 비용뿐만 아니라, 교착상태로부터 회복할 때 내재하는 가능한 손실을 포함하는 오버헤드를 필요로 한다

탐지 알고리즘을 호출하면 오버헤드가 너무 크게 되어, 지정된 시간 간격으로 탐지 알고리즘을 호출 한다. 탐지 알고리즘을 임의의 시간에 호출하면 자원 그래프는 여러 개의 사이클을 포함할 수 있지만 어느 프로세스가 교착상태를 야기한 장본인인지 알아 낼 수 없게 된다.



### 교착상태 회복

1. 순환 대기를 깨뜨리기 위해 한 개 이상의 프로세스를 중지(abort)시키는 것

2. 하나 이상의 프로세스들로부터 자원을 선점하는 것



#### 프로세스 종료

- 교착상태 프로세스를 모두 중지 : 교착 상태의 사이클을 깨지만 비용이 크다.
- 교착상태가 제거될 때까지 한 프로세스 씩 중지 : 탐지 알고리즘을 호출해 프로세스들이 아직도 교착상태에 있는지 확인 해야 하기 때문에 상당한 오버해드를 유발한다.



부분 종료 방식을 사용할 때 교착상태를 깨기 위해서 어느 프로세스를 중지해야 할지 결정하는데 다음과 같은 요인이 있다.

1. 프로세스의 우선순위가 무엇인지
2. 지금까지 프로세스가 수행된 시간과 지정된 일을 종료하는 데 더 필요한 시간
3. 프로세스가 사용한 자원 타입과 수(ex : 자원들을 선점하기가 단순한지 여부)
4. 프로세스가 종료하기 위해 더 필요한 자원의 수
5. 얼마나 많은 수의 프로세스가 종료되어야 하는지
6. 프로세스가 대화형인지 일괄처리인지 여부



#### 자원 선점

1. 희생자 선택 : 비용을 최소화하기 위해 선점의 순서를 결정해야 한다. 비용 요인으로는 교착상태 프로세스가 점유하고 있는 자원의 수 그리고 교착상태 프로세스가 지금까지 실행하는 데 소요한 시간과 같은 매개변수들이 포함될 수 있다.
2. 후퇴(rollback) : 안전 상태가 어떤 것인지를 결정하기 어렵기 때문에, 가장 단순한 해결안은 완전히 후퇴시키는 것이다. 이 방식은 시스템이 실행하는 모든 프로세스들의 상태에 대한 보다 많은 정보를 유지할 것을 필요로 한다.
3. 기아 상태 : 기아 상태가 발생하지 않는 것을 어떻게 보장할 것인가? 프로세스가 한정된 시간 동안만 희생자로 선정된다는 것을 반드시 보장해야 한다. 대부분의 일반적인 해결 방법은 비용 요소에 후퇴의 횟수를 포함시키는 방법이다. 