## Chap14. 포인터 활용



### 이중 포인터란?

포인터의 포인터, 이중 포인터도 주소가 저장되므로 다른 포인터와 마찬가지로 4바이트의 메모리 공간이 필요함.

```c
int i = 100;
int *p = &i;
int **q = &p;	// q는 포인터 p를 가리키는 이중 포인터

*p = 200;		// p를 통하여 i에 200을 저장 => i = 200;
**q = 300;		// q를 통하여 i에 300을 저장 => i = 300;

/// *q = 300; 포인터 *q는 p와 같은데 포인터 p에 주소 300을 대입하는 것은 의미가 없다, 논리적 오류
```



이중 포인터가 많이 사용되는 상황은 외부에서 정의된 포인터 값을 함수의 인수로 받아 변경하려고 하는 경우다.

```c
void set_pointer(char **q);
char *proverb="This is proverb";

int main(void)
{
	char *p = "zzz";
    set_pointer(&p);
    printf("%s \n", p);
    
    return 0;    
}
// 매개변수로 이중포인터 q를 통하여 외부의 포인터 p를 변경함.
void set_pointer(char **q)
{
    *q = proverb;
}
```



### 포인터 배열

**포인터 배열(an array of pointers)**은 포인터들을 모아서 배열로 만든 것이다. 즉 배열의 원소가 포인터이다.

```c
/// 정수형 포인터 배열
int *ap[10];
// 1. []연산자가 *연산자보다 우선순위가 높으므로 ap는 먼저 배열이 된다
// 2. int *(포인터)들의 배열이 된다

// 예시
int a = 10, b = 20, c = 30, d = 40;
int *api[4] = { &a, &b, &c, &d };
```



### 문자형 포인터 배열

포인터 배열 중에서 가장 많이 사용되는 형태는 문자형 포인터 배열이다.

```c
char fname[4][10] = {
	"apple",	// 10칸 중 6개 차지
    "orange",	// 10칸 중 7개 차지
    "melon"
};

// 위 배열의 문제점은 짧은 문자열을 저장하는 행에서 공간이 낭비된다.
```



### 래그드 배열(ragged array)

문자열의 길이가 달라도 메모리의 낭비가 발생하지 않는다.

```c
char *fruits[4] = {
	"apple",	// 6칸 중 6개 차지
    "orange",	// 7칸 중 7개 차지
    "melon"
};
// 각 원소들은 위 문자열의 주소 값으로 초기화 된다.
```

위 배열은 fruits라는 문자형 포인터 배열이 선언되고, 포인터 배열의 원소들은 문자열 상수로 초기화 된다. 컴파일러는 문자열 상수를 만나면 메모리 공간을 할당받아 저장하고 문자열이 저장된 주소 값을 반환한다.



### 배열 포인터

**배열 포인터**는 배열을 가리키는 포인터다.

```c
int (*pa)[10];
// 1. 괄호가 있으므로 pa는 먼저 포인터가 된다.
// 2. int [10]을 가리키는 포인터가 된다
```



p574 함수포인터