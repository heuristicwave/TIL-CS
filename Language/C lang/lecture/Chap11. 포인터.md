## Chap11. 포인터



### 포인터란?

메모리의 주소를 가지고 있는 변수. 컴퓨터에서 메모리는 바이트 단위로 주소가 매겨진다.

```c
int i = 10;
printf("i의 주소: %u\n", &i);	// 변수 i의 주소출력 - %u 부호없는 정수형(unsigned)
```



### 포인터의 선언

포인터는 변수의 주소를 가지고 있는 변수이다. 포인터는 변수이지만 저장하고 있는 것이 메모리의 주소이다. 변수임을 강조하기 위해서 때때로 **포인터 변수**라고 한다. 따라서 사용하기 전에 선언되어야 한다.  

```c
int *p;	// 포인터가 가리키게 되는 대상(int)을 먼저 쓰고 *를 붙이고 포인터의 이름(p)을 씀
```



### 포인터 초기화

10000번지를 (int *) 타입으로 형변환하여서 포인터 p를 초기화 하기
```c
int *p = (int *)10000;
```

임베디드 장치에서는 위와 같은 문장이 가능, 운영체제가 메모리를 관리하는 PC에서는 &연산자를 이용한다.

```c
int i = 10;
int *p;
p = &i;	// 포인터 p에 변수 i의 주소를 저장한다.

int *pi = NULL; // 지역변수로 포인터를 선언하고 초기화 시키지 않으면 쓰레기값이 저장됨
// NULL 값을 저장하는 것은 주소가 0
```

>NULL은 stdio.h 헤더 파일에 다음과 같이 정의된 포인터 상수로 0번지를 의미한다.
>
>NULL이 들어있는 포인터를 널 포인터(null pointer) 
>
>```c
>#define NULL ((void *)0)	// 포인터 변수의 값이 0이면 아무것도 가리키고 있지 않다.
>```



### 간접 참조 연산자 *

포인터 p가 가리키는 주소에 저장된 내용을 읽으려면 p앞에 * 기호를 붙여서 *p하면 된다. => 간접 참조

```c
int i = 10;
int *p;
p = &i;
printf("%d \n", *p);	// 10이 출력
```



### 간접 참조 연산자 *의 해석

*p는 p가 가리키는 위치에 있는 데이터를 가져오라는 의미

p는 p가 가리키는 위치에 무엇이 있는지 모르기 때문에, p가 int형 포인터면 p가 가리키는 위치에 정수가 있다고 가정하고 4바이트를 읽어 들인다.

```c
/// PC에서는 사용 불가
int *pi = (int *)10000;		// 10000번지로 부터 4바이트를 읽어
```



#### &연산자와 *연산자

&연산자 : 변수의 주소를 구하여 간접 참조할 때 사용

*연산자 : 포인터를 통하여 변수를 간접 참조할 때 사용

```c
int i = 3000;
int *p = NULL;

p = &i;

printf("p = %u\n", p);		// 	1245024													
printf("&i = %u\n\n", &i);	//	1245024

printf("i = %d\n", i);		//	3000
printf("*p = %d\n", *p);	//	3000
```



### 포인터 사용시 주의할 점

#### 초기화하지 않고 사용하기

포인터가 아무것도 가리키고 있지 않을 때는 NULL로 설정하는 것이 바람직



#### 포인터 타입과 변수의 타입을 일치하여야 한다

double형 포인터가 int형 변수의 주소가 대입될 경우, 변수 i의 범위를 넘어가서 이웃 바이트를 덮어쓰게 된다.



#### 절대주소 사용

절대 주소는 임베디드 시스템에서만 사용한다.



### 포인터 연산

#### 덧셈과 뺄셈 연산

포인터에 정수를 더하면 포인터의 값에 증가되는 것이 아니라 포인터가 가리키는 자료형의 크기만큼 증가된다.



#### 간접 참조 연산자와 증감 연산자

증감 연산자는 간접 참조 연산지인 *와 같이 사용 될 수 있다.

주의할 점은 증감 연산자를 포인터에 적용할 수도 있고 포인터가 가리키는 대상에 적용할 수도 있다.

```c
*p++;	// p가 가리키는 위치에서 값을 가져온 후에 포인터 p를 증가한다.
=> *p를 먼저 수행한 후에 p에 대하여 ++가 실행된다.
    
// 포인터가 가리키는 대상의 값을 증가하려고 했으면 다음과 같다
(*p)++;
```



예제

```c
main(void)
{
    int i = 10;
    int *pi = &i;
    
    printf()
}
```





#### 포인터의 형변환

```c
double *pd = &f;
int *pi;

pi = (int`*)pd;	// double형 포인터를 int형 포인터로 변환
```



### 포인터와 함수

#### 함수 호출시 인수 전달 방식

- call-by-value : 복사본이 전달된다.
- call-by-reference : 원본이 전달된다.



**call-by-value 예제**

아래 swap함수는 x, y의 값만 바뀔뿐 a, b의 값은 여전히 100, 200 이다.

값에 의한 호출로 인하여 복사본이 교환된 것이다.

```c
void swap(int x, int y)	// 매개변수에 복사된 값이 들어감
{
	int tmp;
	
	tmp =  x;
	x = y;
	y = tmp;
}

int main(void)
{
    int a = 100, b = 200;
    
    swap(a, b);
    
	return 0;
}
```



**call-by-reference**

```c
void swap(int *px, int *py)	// 변수의 주소가 매개변수로 전달됨
{
	int tmp;
	
	tmp =  *px;
	*px = *py;
	*py = tmp;
}

int main(void)
{
    int a = 100, b = 200;
    
    swap(&a, &b);
    
	return 0;
}
```

> **scanf()**
>
> "참조에 의한 호출"을 사용하는 전형적인 예가 바로 scanf이다. 항상 변수들의 주소를 요구하여 변수에 사용자로부터 받은 값을 저장했다.

> **함수가 포인터를 통하여 값을 변경할 수 없게 하려면?**
>
> 함수의 매개 변수를 선언할 때 const를  붙이면 포인터가 기리키는 내용이 변경 불가능한 상수가 된다.
>
> ```c
> void sub(cost int *p) {
>     *p = 0;		// ERROR!!
> }
> ```



#### 포인터를 사용하여 하나 이상의 값 반환하기

C언어에서 return 문장은 하나의 값만을 반환할 수 있다. 그러나, 포인터 인수를 이용하면 2개 이상의 값을 반환 할 수 있다.

```c
int get_line_params(int x1, int y1, int x2, int y2, float *slope, float *yintercept)
{
    if (x1 == x2)
        return -1;
    else {
        *slope = (float)(y2 - y1)/(float)(x2 - x1);
        *yintercept = y1 - (*slope)*x1;
        return 0;
    }
}

int main(void)
{
    float x, y;
    
    if(get_line_params(3, 3, 6, 6, &s, &y) == -1)
        printf("ERROR!!\n");
   else
       printf("기울기는 %f, yw절편은 %f \n", s, y);
    return 0;
}
```



#### 포인터를 사용하는 반환값

함수의 반환값으로 포인터를 사용할 때, 남아 있는 기억 장소의 변수를 반환해야 한다. 예를들어 지역 변수의 경우, 함수가 종료되면 사라지기 때문에 지역변수의 주소를 반환하면 안 된다.

```c
int *add(int x, int y) {
    int result;
    
    result = x + y;
    return &result;	// ERROR!!
}
```



### 포인터와 배열

배열의 이름은 포인터이며 배열이 시작되는 주소와 같다.

포인터와 배열의 관계

```c
int a[] = { 10, 20, 30, 40, 50 };
&a[0] == a	// 동일한 메모리 주소, &a[1]은 a[1]의 메모리 주소
    
printf("a = %u\n", a);				// 배열의 이름을 포인터 처럼 사용
printf("a+1 = %u\n", a+1);			// a+1은 a보다 4가 크며 a[1]의 주소와 같다
printf("*a = %u\n", *a);			// 배열의 이름은 포인터이니 a[0]과 같다. 즉 10 출력
printf("*(a+1) = %u\n", *(a+1));	// 배열의 이름은 포인터와 같음,  a[1]의 값인 20 출력
```

배열의 이름은 **포인터 상수**이기 때문에, 배열의 이름에다 다른 변수의 주소를 대입할 수는 없다. 즉, 그 값이 변경 될 수는 없다.

```c
int a[] = { 10, 20, 30 };
++a;	// 컴파일 오류, a는 포인터 상수이므로 변경 불가
```



#### 포인터를 배열처럼 사용

배열 이름이 포인터이기 때문에 역으로 포인터도 배열 이름처럼 사용 할 수 있다.

```c
int a[] = {10, 20, 30, 40, 50};
int *p;	// a는 포인터 상수 이므로 값을 변경 할 수 없지만, p는 포인터 변수라 값을 변경 할 수 있다.

p = a;	// 배열의 첫 번째 주소가 p에 대입되는 것과 같다.
/// p, a는 같은 곳을 가리키니 다음 두가지 표현 방식은 서로 같다.
// 배열의 사용하여 요소 접근 a[0], a[1], a[2]
// 포인터를 배열처럼 사용하여 요소 접근 p[0], p[1], p[2]

p[0] = 60;	// 포인터를 마치 배열의 이름처럼 사용하여 배열 요소에 값을 대입
p[1] = 70;	// p는 a와 똑같은 곳을 가리키고 있어서 p혹은 a를 사용해도 결과는 같다.
p[2] = 80;	// a[0], a[1], a[2]과 p[0], p[1], p[2]의 출력값은 60, 70, 80으로 동일하다.
```



#### 배열 매개 변수

일반적인 매개 변수

```c
void sub(int x) {
    // x에 실제로 기억 장소가 할당됨
}
```

배열 매개 변수인 경우

```c
void sub(int b[], int size) {
    // 실제로 배열 b가 생성되지 않는다.
    // b는 배열을 가리키는 포인터로서 외부에서 전달된 배열의 주소가 전달된다.
}
```

다른 변수들은 기억 장소를 할당해도 별 문제가 없지만, 배열의 경우 크기가 큰 경우 배열로 전체 내용을 복사해주면 상당한 시간이 소요 되기 때문에 주소를 알려준다.



예제

```c
void sub(int b[], int size)	// 매개변수 b는 전달된 배열을 가리키는 포인터
{
    b[0] = 4;	// b[]를 통하여 원본 배열 a[]가 변경된다.
    b[1] = 5;
    b[2] = 6;
}

int main(void)
{
    int a[3] = {1, 2, 3};
    sub(a, 3);	// 배열 a를 전달, 배열의 이름은 배열의 주소(포인터)이므로 배열의 주소가 전달
    
    return 0;
}
```



> **포인터를 사용하여 빠른 연산하기**
>
> 
>
> 인덱스 표기법
>
> ```c
> int get_sum(int a[], int n) {
>     int i = 0;
>     int sum = 0;
>     
>     for (i=0; i<n; i++)
>         sum += a[i];
>     return sum;
> }
> ```
>
> 포인터 사용
>
> ```c
> int get_sum(int a[], int n) {
>     int i = 0;
>     int sum = 0;
>     int *p;
>     
>     p = a;
>     for (i=0; i<n; i++)
>         sum += *p++;	// 포인터만 증가하면 다음 요소가 된다
>     return sum;
> }
> ```
>
> 포인터 p는 배열의 이름 a로 초기화 되고 배열의 이름은 첫 번째 요소의 주소와 같으므로 p는 첫 번째 요소를 가리킨다. 루프에서 *p를 sum에 더하고 p를 증가시키는 것은 p가 증가되면 p는 배열의 다음 요소를 가리키니, 매번 반복 때마다 배열 요소의 주소를 다시 계산할 필요가 없어서 시간이 더 적게 걸리므로 효율적이다.
>
> 영상처리와 같이 큰 데이터를 다루는 경우 이와 같이 포인터를 이용하는 편이 훨씬 효율적이다.



### 포인터 사용의 장점

- 연결리스트, 이진 트리 등의 향상된 자료 구조
- 메모리 매핑 하드웨어
- 참조에 의한 호출
- 동적 메모리 할당



imageprocessing.c

포인터를 이용하여 영상을 처리하는 예제

2차원 배열로 표현된 영상을 받아서 영상의 밝기를 10만큼 증가시키는 코드

```c
#include <stdio.h>
#define SIZE 5

void print_image(int image[SIZE][SIZE])
{
    int r, c;
    
    for(r=0; r<SIZE; r++) {
        for(c=0; c<SIZE; c++){
            printf("%03d ", image[r][c]);
        }
        printf("\n");
    }
}

void brighten_image(int image[SIZE][SIZE])
{
    int r, c;
    int *p;
    
    p = &image[0][0];	// 첫 번째 픽셀을 가리킴
    for(r=0; r<SIZE; r++) {
        for(c=0; c<SIZE; c++){
            *p += 10;
            p++;	// 포인터를 하나 증가시켜서 다음 픽셀을 가리킴
        }
        printf("\n");
    }
}

int main(void)
{
    int image[SIZE][SIZE] = {
        {10, 20, 30, 40, 50},
        {10, 20, 30, 40, 50},
        {10, 20, 30, 40, 50},
        {10, 20, 30, 40, 50},
        {10, 20, 30, 40, 50}};
    
    print_image(image);
    brighten_image(image);
    print_image(image);
    
    return 0;
}
```

