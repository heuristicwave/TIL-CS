## Chap14. 포인터 활용



### 이중 포인터란?

포인터의 포인터, 이중 포인터도 주소가 저장되므로 다른 포인터와 마찬가지로 4바이트의 메모리 공간이 필요함.

```c
int i = 100;
int *p = &i;
int **q = &p;	// q는 포인터 p를 가리키는 이중 포인터

*p = 200;		// p를 통하여 i에 200을 저장 => i = 200;
**q = 300;		// q를 통하여 i에 300을 저장 => i = 300;

/// *q = 300; 포인터 *q는 p와 같은데 포인터 p에 주소 300을 대입하는 것은 의미가 없다, 논리적 오류
```



이중 포인터가 많이 사용되는 상황은 외부에서 정의된 포인터 값을 함수의 인수로 받아 변경하려고 하는 경우다.

```c
void set_pointer(char **q);
char *proverb="This is proverb";

int main(void)
{
	char *p = "zzz";
    set_pointer(&p);
    printf("%s \n", p);
    
    return 0;    
}
// 매개변수로 이중포인터 q를 통하여 외부의 포인터 p를 변경함.
void set_pointer(char **q)
{
    *q = proverb;
}
```



### 포인터 배열

**포인터 배열(an array of pointers)**은 포인터들을 모아서 배열로 만든 것이다. 즉 배열의 원소가 포인터이다.

```c
/// 정수형 포인터 배열
int *ap[10];
// 1. []연산자가 *연산자보다 우선순위가 높으므로 ap는 먼저 배열이 된다
// 2. int *(포인터)들의 배열이 된다

// 예시
int a = 10, b = 20, c = 30, d = 40;
int *api[4] = { &a, &b, &c, &d };
```



### 문자형 포인터 배열

포인터 배열 중에서 가장 많이 사용되는 형태는 문자형 포인터 배열이다.

```c
char fname[4][10] = {
	"apple",	// 10칸 중 6개 차지
    "orange",	// 10칸 중 7개 차지
    "melon"
};

// 위 배열의 문제점은 짧은 문자열을 저장하는 행에서 공간이 낭비된다.
```



### 래그드 배열(ragged array)

문자열의 길이가 달라도 메모리의 낭비가 발생하지 않는다.

```c
char *fruits[4] = {
	"apple",	// 6칸 중 6개 차지
    "orange",	// 7칸 중 7개 차지
    "melon"
};
// 각 원소들은 위 문자열의 주소 값으로 초기화 된다.
```

위 배열은 fruits라는 문자형 포인터 배열이 선언되고, 포인터 배열의 원소들은 문자열 상수로 초기화 된다. 컴파일러는 문자열 상수를 만나면 메모리 공간을 할당받아 저장하고 문자열이 저장된 주소 값을 반환한다.



### 배열 포인터

**배열 포인터**는 배열을 가리키는 포인터다.

```c
int (*pa)[10];
// 1. 괄호가 있으므로 pa는 먼저 포인터가 된다.
// 2. int [10]을 가리키는 포인터가 된다
```

> [배열 포인터와 포인터 배열에 관하여](<https://enter.tistory.com/127>)

> **포인터 배열과 배열 포인터의 비교**
>
> 포인터의 배열 : int *ap[10];
>
> 배열을 나타내는 []연산자가 *연산자보다 우선 순위가 높다. 포인터들의 배열이 된다.
>
> 
>
> 배열 포인터 : int (*pa)[10];
>
> 괄호 때문에 *연산자가 먼저 적용 되어서 pa는 먼저 포인터가 되어 int [10]을 가리키는 포인터가 된다.



### 함수 포인터

포인터는 함수도 가리킬 수 있다. 함수도 실행이 시작되는 주소를 가지고 있기 때문에 이 주소를 포인터에 넣을 수가 있는 것이다.

```c
int sub(int, int);	// 함수의 원형
int (*pf)(int, int);	// 괄호에 의해 *연산자가 먼저 적용되어 pf는 포인터가 된다
// (*pf) : 함수를 가리키는 포인터 선언
// (int, int) : 포인터가 가리키는 함수의 매개변수 선언
...    
pf = sub;	// 함수의 이름을 함수 포인터에 대입하고 사용!
```

```c
result = (*pf)(10, 20);
// 대부분의 컴파일러는 편의를 위해 아래와 같은 표현 방식을 허용한다.
result = pf(10, 20);
```



#### 함수 포인터의 배열

함수도 실행이 시작되는 주소를 가지고 있기 때문에 이 주소를 포인터에 넣을 수가 있다. 함수 포인터를 사용하여 포인터의 저장된 함수 주소를 이용하여 함수를 호출할 수 있다.

포인터를 이용하여 함수를 호출하려면 포인터가 함수를 가리킨다는 정보와 함수 호출에 필요한 인수, 반환형도 함께 알려주어야 한다.

int f(int, int) 함수를 가리키는 포인터의 정의

```c
int (*pf)(int, int);	// 포인터가 가리키는 함수의 매개변수를 같이 써준다.
// *pf : 함수를 가리키는 포인터를 선언, 반드시 괄호가 필요(pf가 먼저 포인터가 되어야 함) 
```



함수의 이름은 배열의 이름과 마찬가지로 함수의 시작 주소를 나타내는 포인터 상수로 간주된다. 따라서 함수의 이름앞에 &연산자를 사용할 필요가 없다. 반환형과 매개 변수만 일치하면 이름이 다르더라도 함수를 바꿔가며 가리킬 수 있다.

```c
int sub(int, int);		// 함수 원형 정의
int (*pf)(int, int);	// 함수 포인터 정의
...
pf = sub;				// 함수의 이름을 함수 포인터에 대입

// 함수 포인터를 이용하여 함수 호출하기
result = (*pf)(10, 20);	// pf가 함수의 주소를 가지고 있으니 (*pf) = sub
```

> 만약, *pf(10, 20)의 경우 ()연산자의 우선순위 때문에 *(pf(10, 20))과 같은 의미가 되고, 함수 호출 pf(10, 20)이 먼저 실행되고 함수의 반환값이 가리키는 내용이 되어 버린다. 따라서 * 연산자가 먼저 실행되도록 반드시 괄호가 있어야 한다.
>
> (*pf)의 표현이 번거로워 대부분의 컴파일러에서너는 pf를 함수 이름처럼 사용해서 호출하는 것을 허용한다.
>
> 때문에 result = pf(10, 20); 과 같이 사용해도 문제가 없다.



#### 함수 포인터의 배열

함수 포인터도 함수의 주소가 들어 있는 변수이기 때문에 배열로 만들 수 있다. 

```c
int (*pf[5])(int, int);	// pf는 먼저 배열이 되고, 포인터들의 배열이 된고 함수를 가리킨다.
```



#### 함수 인수로서의 함수 포인터

함수 포인터도 변수이기 때문에 함수 호출 시에 인수로 전달이 가능하다. 함수 포인터가 인수로 전달되면 전달받은 함수 측에서는 이 함수 포인터를 이용하여 함수 호출을 할 수 있다.



### 다차원 배열과 포인터

2차원 배열의 이름은 첫 번째 배열 원소의 주소인 `&m[0][0]`과 같다.



#### 다차원 배열의 이해

다차원 배열을 배열의 배열로 이해하자

```c
int m[3][3];
// 배열 m은 m[0], m[1], m[2]이렇게 3 개의 원소로 되어 있는 배열이고 m[0]은 다시 m[0][0], m[0][1], m[0][2]로 되어 있는 배열이다.
```



#### 다차원 배열에서의 포인터 연산

2차원 배열에서 m이 m[0]를 가리킬때, m + 1은 m[1]을 가리킨다.



#### 포인터를 이용한 다차원 배열 운행

```c
double get_total_avg(int m[][COLS]) {
    int *p, int *endp;
    double sum = 0.0;
    
	p = &m[0][0];	// p는 0행의 시작 주소
    endp = &m[ROWS-1][COLS-1];	// endp는 (ROWS-1)행의 종료 주소
    
    while( p <= endp )		// p가 종료 주소보다 작거나 같으면
        sum += *p++;		// sum에 p가 가리키는 값 누적
    
    sum /= ROWS * COLS;
    
    return sum;
}
```



###  const 포인터와 volatile 포인터

#### const 키워드

```c
const char *p;	// p가 가리키는 내용이 변경되지 않는다.
char *const p;	// 포인터 p가 변경되지 않는다.
```



#### volatile 키워드

주로 동일한 메모리를 여러개의 프로세스나 스레드가 사용할 때 필요하다. volatile는 다른 프로세스나 스레드가 값을 항상 변경할 수 있으니 값을 사용할 때마다 다시 메모리에서 읽으라는 것을 의미한다. 변수가 volatile로 지정되면 컴파일러는 프로그램에 의하여 변수가 접근될 때마다 메모리 값을 다시 로드하기 때문에, 컴파일러의 최적화를 방해한다.

```c
volatile char *p;	// p가 가리키는 내용이 수시로 변경되니 사용할 때 마다 다시 로드
```



### void 포인터

void 포인터는 순수하게 메모리의 주소만을 가지고 있는 변수이다. `제네릭 포인터`라고도 한다.

void형 포인터는 가리키는 대상이 없기 때문에 *연산자를 사용할 수 없다. 사용하려면 명시적인 대상을 가리키는 포인터 타입으로 형변환을 하여야한다.

```c
int a = 10;
void *p;		// void 포인터 p 선언

p = &a;			// p는 변수 a의 주소를 가지고 있다.
// printf("%d", *p);	<- 오류!!
printf("%d", *(int *)p);	// OK
```

void 포인터는 어떤 타임의 포인터도 받을 수 잇는 함수를 작성 할 수 있다. 아래는 전달받은 메모리를 0으로 채우는 함수다

```c
void memzero(void *ptr, size_t len) {
    for(; len > 0; len--) {
        *(char *)ptr = 0;
    }
}
```



### main 함수의 인수

```c
int main(void){		// 외부 입력을 받지 않는 main()
}

int main(int argc, char*argv[]){		// 외부 입력을 받을 수 있는 main()
}
// argc : 명령어가 가지는 인수들의 개수
// argv : 명령어가 가지는 인수들을 문자열 형태로 전달
```

console에서 명령을 입력하면

```C
int main(int argc, char *argv[])
{
	int i = 0;

	for (i = 0; i < argc; i++)
		printf("명령어 행에서 %d번째 문자열 = %s\n", i, argv[i]);

	return 0;
}
```

위와 같은 코드를 거쳐 차례로 명령어, 명령 인자1, 명령 인자2가 나온다.

ex) mycopy src dst => mycopy, src, dst